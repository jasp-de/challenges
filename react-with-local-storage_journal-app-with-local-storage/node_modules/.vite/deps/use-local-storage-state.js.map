{
  "version": 3,
  "sources": ["../../use-local-storage-state/src/useLocalStorageState.js", "../../use-local-storage-state/index.js"],
  "sourcesContent": ["import { useCallback, useEffect, useMemo, useRef, useState, useSyncExternalStore } from 'react';\n// in memory fallback used when `localStorage` throws an error\nexport const inMemoryData = new Map();\nexport default function useLocalStorageState(key, options) {\n    const serializer = options?.serializer;\n    const [defaultValue] = useState(options?.defaultValue);\n    return useLocalStorage(key, defaultValue, options?.storageSync, serializer?.parse, serializer?.stringify);\n}\nfunction useLocalStorage(key, defaultValue, storageSync = true, parse = parseJSON, stringify = JSON.stringify) {\n    // we keep the `parsed` value in a ref because `useSyncExternalStore` requires a cached version\n    const storageItem = useRef({\n        string: null,\n        parsed: undefined,\n    });\n    const value = useSyncExternalStore(\n    // useSyncExternalStore.subscribe\n    useCallback((onStoreChange) => {\n        const onChange = (localKey) => {\n            if (key === localKey) {\n                onStoreChange();\n            }\n        };\n        callbacks.add(onChange);\n        return () => {\n            callbacks.delete(onChange);\n        };\n    }, [key]), \n    // useSyncExternalStore.getSnapshot\n    () => {\n        const string = goodTry(() => localStorage.getItem(key)) ?? null;\n        if (inMemoryData.has(key)) {\n            storageItem.current.parsed = inMemoryData.get(key);\n        }\n        else if (string !== storageItem.current.string) {\n            let parsed;\n            try {\n                parsed = string === null ? defaultValue : parse(string);\n            }\n            catch {\n                parsed = defaultValue;\n            }\n            storageItem.current.parsed = parsed;\n        }\n        storageItem.current.string = string;\n        // store default value in localStorage:\n        // - initial issue: https://github.com/astoilkov/use-local-storage-state/issues/26\n        //   issues that were caused by incorrect initial and secondary implementations:\n        //   - https://github.com/astoilkov/use-local-storage-state/issues/30\n        //   - https://github.com/astoilkov/use-local-storage-state/issues/33\n        if (defaultValue !== undefined && string === null) {\n            // reasons for `localStorage` to throw an error:\n            // - maximum quota is exceeded\n            // - under Mobile Safari (since iOS 5) when the user enters private mode\n            //   `localStorage.setItem()` will throw\n            // - trying to access localStorage object when cookies are disabled in Safari throws\n            //   \"SecurityError: The operation is insecure.\"\n            // eslint-disable-next-line no-console\n            goodTry(() => {\n                const string = stringify(defaultValue);\n                localStorage.setItem(key, string);\n                storageItem.current = { string, parsed: defaultValue };\n            });\n        }\n        return storageItem.current.parsed;\n    }, \n    // useSyncExternalStore.getServerSnapshot\n    () => defaultValue);\n    const setState = useCallback((newValue) => {\n        const value = newValue instanceof Function ? newValue(storageItem.current.parsed) : newValue;\n        // reasons for `localStorage` to throw an error:\n        // - maximum quota is exceeded\n        // - under Mobile Safari (since iOS 5) when the user enters private mode\n        //   `localStorage.setItem()` will throw\n        // - trying to access `localStorage` object when cookies are disabled in Safari throws\n        //   \"SecurityError: The operation is insecure.\"\n        try {\n            localStorage.setItem(key, stringify(value));\n            inMemoryData.delete(key);\n        }\n        catch {\n            inMemoryData.set(key, value);\n        }\n        triggerCallbacks(key);\n    }, [key, stringify]);\n    const removeItem = useCallback(() => {\n        goodTry(() => localStorage.removeItem(key));\n        inMemoryData.delete(key);\n        triggerCallbacks(key);\n    }, [key]);\n    // - syncs change across tabs, windows, iframes\n    // - the `storage` event is called only in all tabs, windows, iframe's except the one that\n    //   triggered the change\n    useEffect(() => {\n        if (!storageSync) {\n            return undefined;\n        }\n        const onStorage = (e) => {\n            if (e.key === key && e.storageArea === goodTry(() => localStorage)) {\n                triggerCallbacks(key);\n            }\n        };\n        window.addEventListener('storage', onStorage);\n        return () => window.removeEventListener('storage', onStorage);\n    }, [key, storageSync]);\n    return useMemo(() => [\n        value,\n        setState,\n        {\n            isPersistent: value === defaultValue || !inMemoryData.has(key),\n            removeItem,\n        },\n    ], [key, setState, value, defaultValue, removeItem]);\n}\n// notifies all instances using the same `key` to update\nconst callbacks = new Set();\nfunction triggerCallbacks(key) {\n    for (const callback of [...callbacks]) {\n        callback(key);\n    }\n}\n// a wrapper for `JSON.parse()` that supports \"undefined\" value. otherwise,\n// `JSON.parse(JSON.stringify(undefined))` returns the string \"undefined\" not the value `undefined`\nfunction parseJSON(value) {\n    return value === 'undefined' ? undefined : JSON.parse(value);\n}\nfunction goodTry(tryFn) {\n    try {\n        return tryFn();\n    }\n    catch { }\n}\n", "import useLocalStorageState from './src/useLocalStorageState.js';\nexport default useLocalStorageState;\n"],
  "mappings": "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",
  "names": ["string", "value"]
}
